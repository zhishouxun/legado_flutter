选择 **Isar** 是非常明智的。相比于传统的 SQLite (sqflite)，Isar 是专门为 Flutter 打造的 NoSQL 数据库，支持多线程异步操作、强类型查询，且其**二进制序列化**特性在处理小说章节这种大文本时速度极快。

在设计 Legado 的数据库时，核心挑战在于：**如何高效存储数千章的目录**以及**如何管理 GB 级的文本内容缓存**。

以下是基于 Isar 的高性能模型设计：

---

### 1. 数据库模型 (Collections) 设计

我们将模型拆分为三个核心集合：`BookSource` (书源)、`Book` (书籍/书架)、`Chapter` (章节)。

#### A. 书籍模型 (Book)

存储书籍基本信息、最后阅读位置和书架状态。

```dart
import 'package:isar/isar.dart';

part 'book.g.dart';

@collection
class Book {
  Id id = Isar.autoIncrement; // Isar 自动生成 ID

  @Index(unique: true, replace: true)
  late String bookUrl;      // 书籍详情页 URL，作为唯一标识

  late String title;
  late String author;
  String? coverUrl;
  String? intro;
  String? kind;             // 分类
  String? lastChapterTitle; // 最新章节名
  
  // 书架状态
  bool onShelf = false;     // 是否已加入书架
  int lastReadTime = 0;     // 最后阅读时间戳
  int order = 0;            // 书架排序序号

  // 阅读进度
  int durChapterIndex = 0;  // 当前章节索引
  int durChapterPos = 0;    // 当前章节阅读到的字符位置
  
  @Index()
  late String sourceUrl;    // 归属书源 URL
}

```

#### B. 章节模型 (Chapter)

**关键点：** 目录和章节内容要分离。为了保证加载目录不卡顿，我们将“章节信息”和“章节具体内容”分开存储，或者使用 `Isar` 的 `Link` 功能。

```dart
@collection
class Chapter {
  Id id = Isar.autoIncrement;

  @Index(composite: [CompositeIndex('index')]) // 复合索引，加速特定书的章节查询
  late String bookUrl;      // 属于哪本书

  @Index()
  late int index;           // 章节序号 (0, 1, 2...)
  
  late String title;        // 章节标题
  late String url;          // 章节内容页 URL
  
  // 缓存内容
  String? content;          // 具体的文本内容。由于 Isar 的特性，内容很大时也不会影响索引查询速度
  
  @Index()
  bool isCached = false;    // 是否已下载/缓存
}

```

#### C. 书源模型 (BookSource)

存储解析规则。

```dart
@collection
class BookSource {
  Id id = Isar.autoIncrement;

  @Index(unique: true)
  late String bookSourceUrl; // 唯一 ID

  late String bookSourceName;
  late String bookSourceGroup;
  
  // 存储 JSON 格式的规则，解析时再转为 Map
  late String ruleSearch;
  late String ruleBookInfo;
  late String ruleToc;
  late String ruleContent;
  
  int weight = 0;           // 排序权重
  bool enabled = true;      // 是否启用
}

```

---

### 2. 高性能优化策略 (The "Legado" Way)

#### ① 异步读写分流

Isar 允许在不同的 `Isolate` 中打开数据库。

* **UI Isolate:** 只负责读取书架列表和当前章节。
* **Background Isolate:** 负责下载章节并写入 `content`。这保证了后台下载时，用户翻页完全不掉帧。

#### ② 章节分表查询

不要一次性查询整本书的 `Chapter` 对象（如果有一万章，内存会爆）。
使用 Isar 的 `offset` 和 `limit` 进行分页查询目录。

```dart
// 仅查询目录，不加载内容（利用 Isar 的属性投影优化）
final toc = await isar.chapters
    .filter()
    .bookUrlEqualTo(currentBook.bookUrl)
    .sortByIndex()
    .findAll();

```

#### ③ 文本内容压缩 (选做)

如果你的应用缓存了上千本书，手机空间会紧张。
在写入 `Chapter.content` 之前，可以使用 `dart:io` 里的 `GZipCodec` 压缩文本。读取时解压，这样可以节省约 60% 的空间。

---

### 3. 接下来的架构建议

有了数据库模型后，你的 **Data 层** 应该实现以下 Repository：

1. **`BookRepository`**: 处理 `addToShelf()`, `updateProgress()`, `getShelfBooks()`。
2. **`ChapterRepository`**: 处理 `saveChapters()`, `getChapter(int index)`, `markAsCached()`。

**下一步行动建议：**
你现在已经有了“解析器原型(A)”和“数据库模型(B)”。建议你尝试将两者结合起来，写一个 **“书籍爬取与保存”** 的逻辑。

**你需要我为你展示如何写一个 `DownloaderService`，利用 Isolate 在后台批量下载章节并保存到 Isar 吗？**