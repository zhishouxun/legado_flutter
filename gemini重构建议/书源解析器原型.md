这是一个非常核心的选择。实现一个兼容 Legado 规则的解析器是整个项目的“发动机”。由于 Dart 原生不支持 Jsoup，我们需要构建一个逻辑转换层，将 Legado 的规则（CSS Selector, XPath, JSONPath, JS）映射到 Dart 的工具库上。

以下是一个基于 **Clean Architecture** 理念设计的 `SourceParser` 原型，它展示了如何处理 HTML 解析和 JS 注入。

---

### 1. 核心解析器架构设计

我们需要一个通用的 `LegadoParser`，它能够根据书源定义的规则（`ruleSearch`, `ruleContent` 等）来处理数据。

### 2. 代码实现原型

首先，确保你的 `pubspec.yaml` 中包含：

* `html`: 用于 CSS 选择器。
* `flutter_js`: 用于执行书源中的 JavaScript。
* `xpath_parse`: 用于处理 XPath 规则。

#### A. 解析器基类与环境封装

```dart
import 'package:html/parser.dart' as html_parser;
import 'package:html/dom.dart';
import 'package:flutter_js/flutter_js.dart';

class LegadoParser {
  final JavascriptRuntime _jsRuntime = getJavascriptRuntime();

  /// 核心方法：根据规则解析列表（如搜索结果、目录）
  List<Map<String, dynamic>> parseList(String htmlContent, Map<String, String> rules) {
    var document = html_parser.parse(htmlContent);
    List<Map<String, dynamic>> results = [];

    // 1. 获取列表容器，Legado 规则通常以 '.' 或 '#' 开头
    // 假设 ruleList: "class.item_oc"
    var items = _selectElements(document, rules['ruleList'] ?? '');

    for (var item in items) {
      Map<String, dynamic> data = {};
      
      // 2. 遍历字段规则 (name, author, coverUrl 等)
      rules.forEach((key, rule) {
        if (key != 'ruleList') {
          data[key] = _parseField(item, rule);
        }
      });
      results.add(data);
    }
    return results;
  }

  /// 内部字段解析逻辑
  String _parseField(Element element, String rule) {
    if (rule.isEmpty) return '';

    // 处理 Legado 的基础逻辑：正则、JS 注入、CSS 选择器
    // 示例： "tag.h4@text" 或 "tag.img@src" 或 "{{$.js内容}}"
    
    if (rule.startsWith('{{') && rule.endsWith('}}')) {
      // 执行 JS 逻辑
      String jsCode = rule.substring(2, rule.length - 2);
      return _executeJs(element.outerHtml, jsCode);
    }

    // 简化的 CSS 选择器处理
    if (rule.contains('@')) {
      var parts = rule.split('@');
      var selector = parts[0];
      var attr = parts[1];
      
      var target = element.querySelector(selector);
      if (attr == 'text') return target?.text.trim() ?? '';
      return target?.attributes[attr] ?? '';
    }

    return '';
  }

  /// 执行 JS 注入逻辑（Legado 的精髓）
  String _executeJs(String html, String jsCode) {
    // 在 JS 环境中注入当前 HTML 变量 'result'
    String wrappedJs = """
      var result = `$html`;
      $jsCode
    """;
    try {
      var JsEvalResult = _jsRuntime.evaluate(wrappedJs);
      return JsEvalResult.stringResult;
    } catch (e) {
      return "JS Error: $e";
    }
  }

  List<Element> _selectElements(Document document, String rule) {
    // 这里需要处理 Legado 复杂的选择器逻辑
    return document.querySelectorAll(rule);
  }
}

```

---

### 3. 如何在 Data 层使用它？

在你的 `data/repositories/book_repository_impl.dart` 中，你会这样调用：

```dart
@override
Future<List<Book>> searchBooks(String keyword, BookSource source) async {
  // 1. 发起网络请求
  final response = await dio.get(source.searchUrl.replaceAll('{{key}}', keyword));
  
  // 2. 调用解析器（建议放在 compute 中运行）
  final parser = LegadoParser();
  final List<Map<String, dynamic>> rawResults = parser.parseList(
    response.data, 
    source.getSearchRules(), // 将 BookSource 实体中的规则提取为 Map
  );

  // 3. 将 Map 转换为 Domain 层的实体 Book
  return rawResults.map((json) => BookModel.fromJson(json).toEntity()).toList();
}

```

---

### 4. 关键避坑与后续开发建议

1. **正则转换：** Legado 的书源规则中大量使用 `##` 进行正则替换（例如 `tag.p@text##广告.*##`）。你需要写一个工具类，将这种自定义格式转为 Dart 的 `RegExp.replaceAll`。
2. **JS 环境预设：** Legado 默认在 JS 环境里提供了 `java` 对象（用于调用 Java 复杂函数）。在 Flutter 中，你需要通过 `jsRuntime.onMessage` 预先模拟这些 Bridge，否则很多高级书源会报错。
3. **XPath 支持：** 很多旧版书源使用 XPath。建议在 `_parseField` 中增加判断，如果规则以 `//` 开头，则切换到 `xpath_parse` 库。

**这个原型展示了如何解耦解析逻辑。你觉得对于 Legado 复杂的“嵌套规则”（即规则里套规则），我需要为你展示如何递归处理吗？**