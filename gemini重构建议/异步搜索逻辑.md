在 Legado 中，搜索体验的优劣取决于两点：**快（并发请求）和稳（UI 不卡顿）**。

在 Flutter 中实现“同时请求 50 个书源”，如果处理不当（如：在主线程解析大量 HTML、频繁调用 `setState`），会导致严重的掉帧。

以下是基于 **Clean Architecture** 理念，使用 `Stream` 和 `Isolate` 实现的高性能异步搜索方案。

---

### 1. 核心架构设计

我们采用 **“流式加载 (Streaming)”** 的模式：

1. **并发控制：** 使用 `Future.wait` 或 `Pool` 限制最大并发数（避免被目标网站封 IP）。
2. **后台解析：** 使用 `compute` 或单独的 `Isolate` 处理解析逻辑。
3. **响应式 UI：** 通过 `StreamBuilder` 或 `Riverpod StreamProvider` 实时显示搜索到的结果。

---

### 2. 代码实现原型

#### A. 定义搜索结果实体

```dart
class SearchResult {
  final Book book;
  final String sourceName;
  final bool isError;

  SearchResult({required this.book, required this.sourceName, this.isError = false});
}

```

#### B. 核心搜索服务 (Domain/Data 层)

这里的重点是利用 `Stream` 的 `async*` 特性，让搜索结果“出一个显示一个”。

```dart
import 'dart:async';
import 'package:flutter/foundation.dart';

class SearchService {
  final BookRepository _repository; // 注入 Repo

  SearchService(this._repository);

  /// 异步搜索流
  Stream<SearchResult> searchAllSources(String keyword, List<BookSource> sources) async* {
    // 1. 将搜索任务包装成多个 Future
    final tasks = sources.map((source) async {
      try {
        // 使用 compute 将耗时的“网络请求+解析”丢到子 Isolate
        // 避免主线程因为大量 HTML 解析而卡顿
        return await compute(_searchSingleSource, {
          'keyword': keyword,
          'source': source,
        });
      } catch (e) {
        return <SearchResult>[]; // 失败返回空列表
      }
    });

    // 2. 使用 Stream.fromFutures 并行执行
    // 这会让结果按照完成的先后顺序流出，而不是等待全部完成
    yield* Stream.fromFutures(tasks).expand((results) => results);
  }
}

/// 顶层函数：必须是顶层函数或静态方法，才能被 compute 调用
Future<List<SearchResult>> _searchSingleSource(Map<String, dynamic> params) async {
  String keyword = params['keyword'];
  BookSource source = params['source'];
  
  // 1. 初始化解析器 (见之前的 A 原型)
  final parser = LegadoParser();
  
  // 2. 执行网络请求 (注意：Isolate 中需重新初始化网络库)
  // final html = await Dio().get(source.searchUrl...);
  
  // 3. 解析并返回结果
  // List<Map> rawData = parser.parseList(html, source.ruleSearch);
  // return rawData.map((item) => SearchResult(...)).toList();
  
  return []; // 示例返回
}

```

---

### 3. UI 层实时渲染 (Presentation 层)

在 UI 界面，使用 `StreamBuilder` 监听这个流。这样用户每搜索到一个书源的结果，书架列表就会立即更新，体验非常顺滑。

```dart
// 在 Widget 中调用
StreamBuilder<SearchResult>(
  stream: searchService.searchAllSources("诡秘之主", enabledSources),
  builder: (context, snapshot) {
    if (snapshot.hasData) {
      // 每当有一个书源返回结果，这里就会被触发
      // 将新到的书籍加入到当前的 UI 列表中
      _tempResults.add(snapshot.data!);
    }
    
    return ListView.builder(
      itemCount: _tempResults.length,
      itemBuilder: (context, index) => BookTile(_tempResults[index]),
    );
  },
);

```

---

### 4. 针对 50 个书源的性能调优建议

1. **分批次 (Batching)：** 虽然是异步，但同时瞬间启动 50 个 `compute` (Isolate) 会造成内存抖动。建议使用 `parallel_queue` 插件或手动限制并发数（例如一次只跑 10 个书源，跑完一个补一个）。
2. **图片懒加载：** 搜索结果通常带有封面图。务必使用 `cached_network_image`。在快速滑动列表时，图片的解码开销远大于文字。
3. **结果去重：** 不同书源可能会搜到同一本书。在 `Stream` 的输出端（UI 层），根据 `title` 和 `author` 做简单的去重逻辑。
4. **取消搜索：** 当用户点击“返回”或重新输入时，务必取消当前的 `StreamSubscription`。

### 后续建议

你已经拥有了：

* **A (解析器逻辑)**：如何处理规则。
* **B (数据库设计)**：如何持久化。
* **C (并发搜索)**：如何流畅地获取数据。

**这三个模块构成了阅读器的“骨架”。你接下来是想尝试把它们整合在一起实现一个“搜索页面”的完整 Demo，还是研究最难的“分页渲染算法”？**