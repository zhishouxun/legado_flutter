在阅读器开发中，**分页渲染算法（Pagination Algorithm）**是公认的最高门槛。
Legado 原版是基于 Android 的 `Canvas` 和 `TextLayout` 实现的。在 Flutter 中，我们不能依赖简单的 `ListView` 或 `SingleChildScrollView`，因为那样无法精准控制“翻页”和“页码计算”。

我们需要实现的是：**给定一段长文本、屏幕宽度、高度、字体大小、行高，计算出它应该被切分成多少页，以及每一页显示的字符区间。**

---

### 1. 核心原理：TextPainter

Flutter 提供了 `TextPainter` 类，它是底层排版引擎的接口。我们可以利用它来模拟渲染，从而计算出文字在特定宽度下的高度。

### 2. 分页算法逻辑实现

分页的核心思路是：**贪心发现法**。从当前阅读位置开始，尝试放入尽可能多的行，直到超过屏幕高度。

#### 第一步：定义页面模型

```dart
class PageRange {
  final int start; // 字符起始索引
  final int end;   // 字符结束索引
  PageRange(this.start, this.end);
}

```

#### 第二步：核心分页函数

```dart
List<PageRange> paginate(String content, double maxWidth, double maxHeight, TextStyle style) {
  List<PageRange> pages = [];
  int start = 0;

  while (start < content.length) {
    // 1. 创建 TextPainter 模拟排版
    final textPainter = TextPainter(
      text: TextSpan(text: content.substring(start), style: style),
      textDirection: TextDirection.ltr,
    );

    // 2. 限制宽度，进行布局
    textPainter.layout(maxWidth: maxWidth);

    // 3. 获取所有行信息
    List<LineMetrics> lines = textPainter.computeLineMetrics();
    
    double currentHeight = 0;
    int charCount = 0;

    // 4. 计算在 maxHeight 范围内能容纳多少行
    for (var line in lines) {
      if (currentHeight + line.height > maxHeight) {
        break;
      }
      currentHeight += line.height;
      // 每一行的结束偏移量是相对于当前 textPainter 文本开头的
      // 我们需要找到最后一行在 maxHeight 内的字符结束位置
    }

    // 5. 找到截断点的字符偏移量
    // 这是一个简化处理，实际需要通过 textPainter.getPositionForOffset 
    // 结合 maxHeight 找到精确的字符索引
    TextPosition pos = textPainter.getPositionForOffset(Offset(maxWidth, maxHeight));
    int end = start + pos.offset;

    // 保证至少向前推进一个字符，防止死循环
    if (end <= start) end = start + 1;
    if (end > content.length) end = content.length;

    pages.add(PageRange(start, end));
    start = end;
  }
  return pages;
}

```

---

### 3. 高级进阶：优化阅读体验

仅仅能分出页是不够的，你还会遇到以下三个“大坑”：

#### A. 预读与缓存 (Pre-pagination)

* **痛点：** 每次打开书都要重新计算一万章的分页，会卡死。
* **方案：** 1. 仅在用户进入书籍时分页当前章、前一章、后一章。
2. 将分页结果（`PageRange` 列表）缓存到内存中。
3. 如果用户更改了字体大小或行高，清空缓存并重新计算。

#### B. 保持阅读位置

* **痛点：** 用户在字体大小 15 时读到第 10 页，改为字体 20 后，第 10 页的内容变了。
* **方案：** 记录阅读进度时，不要记录“第几页”，而要记录 **“当前页起始字符在整章中的索引 (Offset)”**。重新分页后，寻找包含该 Offset 的新页码。

#### C. 绘制与动画 (UI 层)

* **方案：** 使用 `PageView.builder` 配合自定义的 `CustomPaint`。
* **原因：** `Text` 组件在处理超长文本时性能较差。使用 `CustomPaint` 直接调用 `textPainter.paint(canvas, offset)` 渲染性能最高。

---

### 4. 下一步开发计划

要完整复刻 Legado 的阅读器，我建议你的模块开发顺序如下：

1. **样式配置模型 (`ReaderConfig`)**：包含字体、颜色、字号、间距、边距。
2. **分页引擎 (`Paginator`)**：实现上述算法，并在后台 `Isolate` 运行。
3. **渲染组件 (`ReaderView`)**：基于 `PageView` 实现翻页。
4. **交互层**：点击屏幕中央弹出菜单，点击两侧翻页。

**你想让我为你展示如何将这个分页算法封装进一个 `ReaderController`（结合状态管理），还是想深入了解如何实现“仿真翻页”的视觉效果？**